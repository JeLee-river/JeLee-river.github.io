---
layout: post
title: "(7/17) 리팩토링 일지: `useEffect` 무한루프 트러블 슈팅"
date: 2023-07-17
categories: [Project]
toc: true
toc_sticky: true
math: true
mermaid: true
---

# 트러블 슈팅(Trouble Shooting)

> 리팩토링 과정에서 의도하지 않은 동작이나 오류를 마주했다. 이번 글은 이를 해결한 과정에서 배운 점을 정리한 것이다.

<br>

## 문제 인식: useEffect가 무한루프하는 문제 발생

목적지 리스트가 렌더링 되지 않는 원인을 파악하고자 `console.log`로 코드를 점검하던 중, fetch 함수를 실행하는 `useEffect`가 무한 루프 되고 있다는 사실을 발견했다. 이에 따라, `useEffect` 무한 루프를 먼저 해결하기로 했다.

![useEffect Console Image]({{site.img_url}}/useEffectLoop.png)

### 가설 설정 및 검증

**가설 1. `useEffect` 의존성 배열이 잘못 작성되었다.**

> 가설 검증하기: `useEffect`의 의존성 배열 점검

- 첫번째로 `useEffect`의 의존성 배열을 점검했다. `useEffect`가 참조하고 있던 의존성을 제거하고 다시 넣어보며 코드를 재실행했다. 그 결과, **`useEffect`의 의존성 배열에 하나라도 참조값이 존재하면 `useEffect`가 무한히 반복**된다는 사실을 파악했다. 다음은 문제가 발생한 `useEffect` 코드이다.

  ```javascript
  useEffect(() => {
    getCategoryIdList();
    getfilteredResult(searchQueryParams, defaultCategoryIdList);
    console.log("debug useDestinationsFetch useEffect"); //디버깅을 위해 추가한 line
  }, [
    getCategoryIdList,
    getfilteredResult,
    searchQueryParams,
    defaultCategoryIdList,
  ]);
  ```

- 일반적으로 `useEffect`가 무한히 반복되는 이유는 `useEffect` 내부의 로직이 `useEffect`가 참조하고 있는 값을 변경하기 때문이다. 그러나 문제가 발생한 `useEffect`에는 이를 바꾸는 로직이 존재하지 않았다. `useEffect`가 참조하고 있는 함수들도 `useCallback`으로 메모리 주소값을 고정해두었기 때문에 렌더링 마다 다른 함수로 인식할 가능성이 없었다.

- 코드상으로는 문제가 없어 보였지만, 확실히 하기 위해 의존성 배열의 값들을 하나씩 가감하면서 직접 점검하였다.  
  하지만 이번에도 내 예상과 다른 결과를 얻었다. **`getfilteredResult` 함수의 인자로 사용되는 `defaultCategoryIdList`가 무한 루프의 원인이었던 것이다.**  
  또한 `useEffect` 뿐만 아니라 커스텀 훅 자체도 무한히 호출되고 있었다.
  `defaultCategoryIdList`와 관련된 코드는 다음과 같다.

```javascript
const [defaultCategoryIdList, setDefaultCategoryIdList] = useState<number[]>([]);

const getCategoryIdList = useCallback(async () => {
  const res = await getAllCategoryList();
  setDefaultCategoryIdList(extractCategoryIdFromCategoryList([res?.data]));
  return;
}, [
  getAllCategoryList,
  setDefaultCategoryIdList,
  extractCategoryIdFromCategoryList,
]);
```

<br>

> 문제 해결하기: `useEffect` 코드 분석하기

- `getCategoryIdList`함수는 `DefaultCategoryIdList`의 상태를 변경하고 있다. 이에 따라 `getCategoryIdList`함수가 호출되면 `DefaultCategoryIdList`를 참조하는 사이드 이펙트가 실행된다. 이 때, 사이드 이펙트로 `getCategoryIdList`가 다시 호출되면서 위 과정이 반복된다.  
  즉, `DefaultCategoryIdList` 변경 -> 사이드 이펙트 발생이 끝없이 반복되면서 `useDestinations` 커스텀 훅이 무한루프가 된 것이다.

- **이를 해결하기 위해 `useEffect`의 코드를 분석했다.** `useEffect`는 다음의 두 가지 기능을 수행한다.

  1. `getCategoryIdList`함수 호출
  2. `getfilteredResult`함수 호출

  위의 두 함수를 연이어 호출한 이유는 `getCategoryIdList`를 실행했을 때 얻을 수 있는 `categoryIdList`가 `getfilteredResult`의 인자로 필요했기 때문이다. **다시 말해, `getCategoryIdList`가 하나의 독립적인 함수임을 인지하지 못하고 단순히 `categoryIdList`를 얻기 위한 매개체로서의 역할만 생각했다.**  
  하나의 `useEffect`가 두 가지 기능을 수행하도록 만들었다는 사실을 파악하지 못하고 '`getCategoryIdList`가 실행되도록 만들었다!' 정도로만 생각하고 넘어간 것이다.

- **`getCategoryIdList`의 로직을 `useEffect` 내부에서 파악할 수 없는 점도 문제를 빠르게 인지하지 못한 원인이기도 하다.** `getCategoryIdList` 내부의 상태변경 함수를 `useEffect` 코드를 살피는 것 만으로 알 수 없기 때문에 무엇이 잘못되었는지 인지하지 못했다.

---

> 문제 해결하기: `useEffect` 내부 코드 분리하기

- 위와 같은 인사이트를 토대로, 두 가지 기능을 수행하는 `useEffect`의 코드를 분리하기로 결정했다. 1차로 변경한 코드는 다음과 같다.

```javascript
//useEffect 로직
useEffect(() => {
  getCategoryIdList();
}, [getCategoryIdList]);

useEffect(() => {
  getfilteredResult(searchQueryParams, defaultCategoryIdList);
  console.log("debug useDestinationsFetch useEffect"); //디버깅을 위해 추가한 line
}, [getfilteredResult, searchQueryParams, defaultCategoryIdList]);
```

그러나 여기서 또 한 가지 마음에 걸리는 점이 생겼다. `getCategoryIdList`함수의 역할이 이 코드가 위치한 `useDestinations` 커스텀 훅의 역할과 결이 맞는가? 하는 의문이 든 것이다. `useDestinations` 커스텀 훅은 여행지 리스트 데이터를 fetch하기 위해 만든 커스텀 훅이다. 게다가 카테고리 데이터를 fetch하는 로직을 담당하는 `useCategory` 커스텀 훅도 이미 존재하고 있다.  
로직을 분리하자, `getCategoryIdList`의 이질적인 면을 파악할 수 있게 되었다.

- 결과적으로 `getCategoryIdList` 함수는 `useCategory` 커스텀 훅으로 이동하게 되었다. 그리고 `getfilteredResult`함수는 `useCategory`에서 관리하는 state를 인자로 받도록 코드를 수정하였다.

```javascript
const { categoryList, categoryIdList, selectedCategory } = useCategory();

useEffect(() => {
  getfilteredResult(searchQueryParams, selectedCategory);
}, [getfilteredResult, searchQueryParams, selectedCategory]);
```

---

<br>

## 고찰

이번 트러블 슈팅으로 배운 점이 두 가지 있다.

**첫째, 하나의 함수는 하나의 역할만 하도록 코드를 작성하자.**
두 가지 기능을 수행하는 사이드 이펙트는 무한루프에 빠질 수 있다.

**둘째, 코드를 선언적으로 작성하자.**  
내 코드가 정상적으로 보여도 컴퓨터는 거짓말하지 않는다. 무한루프가 발생하면 `useEffect`의 영향범위를 다시 한 번 점검하자. 무엇보다도, 코드를 선언적으로 작성하여 이러한 휴먼에러에 기인한 오류를 최소화 하도록 하자.
